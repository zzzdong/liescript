program = { SOI ~ top_level* ~ EOI }

top_level = { statment | expression }

/// Statment
statment = {
    item_statment
  | expression_statment
  | let_statment
  | if_statment
  | switch_statment
  | loop_statment
  | for_statment
  | return_statment
  | continue_statment
  | break_statment
}

/// Item Statment
item_statment = { fn_item | struct_item | enum_item }

/// Struct Item
struct_item = { "struct" ~ identifier ~ "{" ~ struct_field_list ~ "}" }

struct_field_list = { (struct_field ~ ",")* ~ struct_field? }
struct_field      = { identifier ~ ":" ~ type_expression }

/// Function Item
fn_item = { "fn" ~ identifier ~ "(" ~ fn_param_list ~ ")" ~ ("->" ~ type_expression)? ~ block }

fn_param_list = { (fn_param ~ ",")* ~ fn_param? }

fn_param = { identifier ~ (":" ~ type_expression)? }

/// Enum Item
enum_item = { "enum" ~ identifier ~ "{" ~ enum_item_list ~ "}" }

enum_item_list = { (enum_field ~ ",")* ~ enum_field? }

enum_field = { tuple_enum_field | simple_enum_field }

simple_enum_field = { identifier }

tuple_enum_field = { identifier ~ "(" ~ (type_expression ~ ",")* ~ type_expression ~ ")" }

/// Expression Statment
expression_statment = { expression ~ ";" }

/// Let Statment
let_statment = { "let" ~ identifier ~ "=" ~ expression ~ ";" }

/// If Statment
if_statment = { "if" ~ expression ~ block ~ ("else" ~ block)? }

/// Switch Statment
switch_statment = { "switch" ~ expression ~ "{" ~ case_statment_list ~ "}" }

/// Case Statment
case_statment = { "case" ~ expression ~ ":" ~ block }

/// Case Statment List
case_statment_list = { case_statment* }

/// Loop Statment
loop_statment = { "loop" ~ block }

/// For Statment
for_statment = { "for" ~ expression ~ "in" ~ expression ~ block }

/// Return Statment
return_statment = { "return" ~ expression? ~ ";" }

/// Continue Statment
continue_statment = { "continue" ~ ";" }

/// Break Statment
break_statment = { "break" ~ ";" }

/// Block
block = { "{" ~ (statment | expression)* ~ "}" }

/// Expression
expression = { prefix_operator? ~ primary ~ postfix_operator? ~ (infix_operator ~ prefix_operator? ~ primary ~ postfix_operator?)* }

type_expression = { "bool" | "char" | "int" | "float" | "string" | identifier }

/// Primary
primary = _{ call_expression | slice_expression | index_expression | atom | grouped_expression }

/// Grouped Expression
grouped_expression = { "(" ~ expression ~ ")" }

/// Call Expression
call_expression = { atom ~ "(" ~ call_arg_list? ~ ")" }

call_arg_list = { call_arg ~ ("," ~ call_arg)* }

call_arg = { expression }

/// Index Expression
index_expression = { atom ~ "[" ~ index_arg ~ "]" }

index_arg = { expression }

/// Slice Expression
slice_expression = { atom ~ "[" ~ slice_start? ~ ".." ~ slice_end? ~ "]" }

slice_start = { expression }

slice_end = { expression }

/// Atom
atom = {
    identifier
  | literal
  | tuple
  | array
}

/// Tuple
tuple = { "(" ~ (((expression ~ ",")+ ~ expression) | (expression ~ ",")) ~ ")" }

/// Array
array = { "[" ~ expression ~ ("," ~ expression)* ~ "]" }

/// Literal
literal = { boolean | integer | float | string | character }

/// Boolean
boolean = @{ "true" | "false" }

/// Integer
integer = @{ (ASCII_NONZERO_DIGIT ~ ASCII_DIGIT+ | ASCII_DIGIT) }

/// float
float = @{ integer ~ "." ~ integer }

/// Opening brace for a rule.
opening_brace = { "{" }

/// Closing brace for a rule.
closing_brace = { "}" }

/// Opening parenthesis for a branch, PUSH, etc.
opening_paren = { "(" }

/// Closing parenthesis for a branch, PUSH, etc.
closing_paren = { ")" }

/// Opening bracket for PEEK (slice inside).
opening_brack = { "[" }

/// Closing bracket for PEEK (slice inside).
closing_brack = { "]" }

/// Possible predicates for a rule.
prefix_operator = _{ not_operator | negative_operator }

/// Branches or sequences.
infix_operator = _{
    range_operator
  | add_assign_operator
  | sub_assign_operator
  | mul_assign_operator
  | div_assign_operator
  | mod_assign_operator
  | not_equal_operator
  | less_equal_operator
  | greater_equal_operator
  | as_operator
  | path_operator
  | add_operator
  | sub_operator
  | mul_operator
  | div_operator
  | mod_operator
  | pow_operator
  | range_operator
  | and_operator
  | or_operator
  | equal_operator
  | less_operator
  | greater_operator
  | assign_operator
  | dot_operator
}

/// Possible modifiers for a rule.
postfix_operator = _{
    try_operator
}

/// A not operator.
not_operator = { "!" }

/// A negative operator.
negative_operator = { "-" }

/// A as cast
as_operator = { "as" }

/// A path operator.
path_operator = { "::" }

/// A dot operator.
dot_operator = { "." }

/// A add operator.
add_operator = { "+" }

/// A sub operator.
sub_operator = { "-" }

/// A mul operator.
mul_operator = { "*" }

/// A div operator.
div_operator = { "/" }

/// A mod operator.
mod_operator = { "%" }

/// A pow operator.
pow_operator = { "^" }

/// A try operator.
try_operator = { "?" }

/// A range operator.
range_operator = { "..=" }

/// A and operator.
and_operator = { "&&" }

/// A or operator.
or_operator = { "||" }

/// An equal operator.
equal_operator = { "==" }

/// A not equal operator.
not_equal_operator = { "!=" }

/// A less operator.
less_operator = { "<" }

/// A less equal operator.
less_equal_operator = { "<=" }

/// A greater operator.
greater_operator = { ">" }

/// A greater equal operator.
greater_equal_operator = { ">=" }

/// A assign operator.
assign_operator = { "=" }

/// A add assign operator.
add_assign_operator = { "+=" }

/// A sub assign operator.
sub_assign_operator = { "-=" }

/// A mul assign operator.
mul_assign_operator = { "*=" }

/// A div assign operator.
div_assign_operator = { "/=" }

/// A mod assign operator.
mod_assign_operator = { "%=" }

/// A comma terminal.
comma = { "," }

/// An identifier.
identifier = { !keywords ~ name }

///
name = @{ !"PUSH" ~ ("_" | alpha) ~ ("_" | alpha_num)* }

/// An alpha character.
alpha = _{ 'a'..'z' | 'A'..'Z' }

/// An alphanumeric character.
alpha_num = _{ alpha | '0'..'9' }

/// A string.
string = ${ quote ~ inner_str ~ quote }

/// A single quoted character
character = ${ single_quote ~ inner_chr ~ single_quote }

/// A quoted string.
inner_str = @{ (!("\"" | "\\") ~ ANY)* ~ (escape ~ inner_str)? }

/// An escaped or any character.
inner_chr = @{ escape | ANY }

/// An escape sequence.
escape = @{ "\\" ~ ("\"" | "\\" | "r" | "n" | "t" | "0" | "'" | code | unicode) }

/// A hexadecimal code.
code = @{ "x" ~ hex_digit{2} }

/// A unicode code.
unicode = @{ "u" ~ opening_brace ~ hex_digit{2, 6} ~ closing_brace }

/// A hexadecimal digit.
hex_digit = @{ '0'..'9' | 'a'..'f' | 'A'..'F' }

/// A double quote.
quote = { "\"" }

/// A single quote.
single_quote = { "'" }

/// A newline character.
newline = _{ "\n" | "\r\n" }

/// A whitespace character.
WHITESPACE = _{ " " | "\t" | newline }

/// A single line comment.
line_comment = _{ ("//" ~ !("/" | "!") ~ (!newline ~ ANY)*) }

/// A multi-line comment.
block_comment = _{ "/*" ~ (block_comment | !"*/" ~ ANY)* ~ "*/" }

/// A grammar comment.
COMMENT = _{ block_comment | line_comment }

// ref: https://doc.rust-lang.org/reference/comments.html
/// A space character.
space = _{ " " | "\t" }

/// A top-level comment.
grammar_doc = ${ "//!" ~ space? ~ inner_doc }

/// A rule comment.
line_doc = ${ "///" ~ space? ~ inner_doc }

/// A comment content.
inner_doc = @{ (!newline ~ ANY)* }

/// Keywords
keywords = _{
    "bool"
  | "byte"
  | "char"
  | "int"
  | "float"
  | "string"
  | "true"
  | "false"
  | "enum"
  | "struct"
  | "fn"
  | "let"
  | "const"
  | "static"
  | "mut"
  | "use"
  | "type"
  | "impl"
  | "as"
  | "pub"
  | "priv"
  | "break"
  | "continue"
  | "try"
  | "catch"
  | "finally"
  | "return"
  | "if"
  | "else"
  | "for"
  | "in"
  | "while"
  | "loop"
}
