/// The top-level rule of a grammar.
program = _{ SOI ~ statements ~ EOI }

statements = { statement* }

/// A rule of a grammar.
statement = {
    let_statement
  | item_statement
  | semicolon_statement
  | expression_statement
}

/// let statement
let_statement = { let_keyword ~ identifier ~ assignment_operator ~ expression ~ semicolon }

/// item statement
item_statement = { use_item | enum_item | struct_item | function_item }

/// expression statement
expression_statement = { expression }

/// semicolon statement
semicolon_statement = { expression ~ semicolon }

/// use item
use_item = { use_keyword ~ path_tree ~ semicolon }

path_tree = { identifier ~ (path_operator ~ identifier)* ~ ((as_keyword ~ identifier) | (path_operator ~ path_subtree))? }

path_subtree = { opening_brace ~ (path_tree ~ (comma ~ path_tree)*)? ~ closing_brace }

/// enum item
enum_item = { enum_keyword ~ identifier ~ opening_brace ~ (enum_field ~ comma)* ~ closing_brace }

enum_field = { identifier ~ ( opening_paren ~ pat_type ~ closing_paren )? }

/// struct item
struct_item = { struct_keyword ~ identifier ~ opening_brace ~ (struct_field ~ comma)* ~ closing_brace }

struct_field = { identifier ~ colon ~ pat_type }

function_item = {
    function_keyword ~ identifier ~ opening_paren ~ parameters ~ closing_paren ~ block_expression
}

parameters = { (parameter ~ (comma ~ parameter)*) | parameter? }

parameter = { identifier ~ colon ~ pat_type }

pat_type = { primitive_type | path_type }

path_type = { first_pathseg ~ (path_operator ~ identifier)* }

primitive_type = { byte_keyword | bool_keyword | int_keyword | float_keyword | string_keyword }

first_pathseg = { crate_keyword | super_keyword | self_keyword | identifier }

expression = {
    if_expression
  | while_expression
  | for_expression
  | call_expression
  | identifier_expression
  | literal_expression

}

identifier_expression = { identifier }

literal_expression = {
  string
  | integer
  | float
  | boolean
}

if_expression = {
    if_keyword ~ expression ~ block_expression ~ (else_keyword ~ (block_expression | if_expression))?
}

while_expression = {
    while_keyword ~ expression ~ block_expression
}

for_expression = {
    for_keyword ~ in_expression ~ block_expression
}

in_expression = { identifier ~ in_keyword ~ expression }

block_expression = { opening_brace ~ statements ~ closing_brace }

call_expression = { identifier ~ opening_paren ~ arguments ~ closing_paren }

arguments = { (argument ~ (comma ~ argument)*) | argument? }

argument = { expression }

/// An boolean
boolean = { true_keyword | false_keyword }

/// An identifier.
identifier = @{ !"PUSH" ~ ("_" | alpha) ~ ("_" | alpha_num)* }

/// An alpha character.
alpha = _{ 'a'..'z' | 'A'..'Z' }

/// An alphanumeric character.
alpha_num = _{ alpha | '0'..'9' }

/// An digit num
digit = _{ '0'..'9' }

/// A string.
string = ${ quote ~ inner_str ~ quote }

/// An insensitive string.
insensitive_string = { "^" ~ string }

/// A character range.
range = { character ~ range_operator ~ character }

/// A single quoted character
character = ${ single_quote ~ inner_chr ~ single_quote }

/// A quoted string.
inner_str = @{ (!("\"" | "\\") ~ ANY)* ~ (escape ~ inner_str)? }

/// An escaped or any character.
inner_chr = @{ escape | ANY }

/// An escape sequence.
escape = @{ "\\" ~ ("\"" | "\\" | "r" | "n" | "t" | "0" | "'" | code | unicode) }

/// A hexadecimal code.
code = @{ "x" ~ hex_digit{2} }

/// A unicode code.
unicode = @{ "u" ~ opening_brace ~ hex_digit{2, 6} ~ closing_brace }

/// A hexadecimal digit.
hex_digit = @{ '0'..'9' | 'a'..'f' | 'A'..'F' }

/// A double quote.
quote = { "\"" }

/// A single quote.
single_quote = { "'" }

integer = @{ "0" | ASCII_NONZERO_DIGIT ~ ASCII_DIGIT* }

float = @{ integer ~ dot_operator ~ integer }
exp   = @{ ("E" | "e") ~ ("+" | "-")? ~ ASCII_DIGIT+ }

// =====================

/// A range operator.
range_operator = { ".." }

/// Path operator.
path_operator = { "::" }

/// Arrow operator.
arrow_operator = { "->" }

/// Add operator.
add_operator = { "+" }

/// Minus operator.
minus_operator = { "-" }

/// Dot operator.
dot_operator = { "." }

/// Assignment operator.
assignment_operator = { "=" }

/// Opening brace for a rule.
opening_brace = { "{" }

/// Closing brace for a rule.
closing_brace = { "}" }

/// Opening parenthesis for a branch, PUSH, etc.
opening_paren = { "(" }

/// Closing parenthesis for a branch, PUSH, etc.
closing_paren = { ")" }

/// Opening bracket for PEEK (slice inside).
opening_brack = { "[" }

/// Closing bracket for PEEK (slice inside).
closing_brack = { "]" }

// separators
colon     = { ":" }
comma     = { "," }
semicolon = { ";" }


enum_keyword = { "enum" }
struct_keyword   = { "struct" }
let_keyword      = { "let" }
function_keyword = { "fn" }
use_keyword      = { "use" }
for_keyword      = { "for" }
while_keyword    = { "while" }
if_keyword       = { "if" }
true_keyword     = { "true" }
false_keyword    = { "false" }
in_keyword       = { "in" }
else_keyword     = { "else" }
as_keyword       = { "as" }
self_keyword     = { "self" }
crate_keyword    = { "crate" }
super_keyword    = { "super" }
bool_keyword     = { "bool" }
byte_keyword     = { "byte" }
int_keyword      = { "int" }
float_keyword    = { "float" }
string_keyword   = { "string" }

/// A newline character.
newline = _{ "\n" | "\r\n" }

/// A whitespace character.
WHITESPACE = _{ " " | "\t" | newline }

/// A single line comment.
line_comment = _{ ("//" ~ !("/" | "!") ~ (!newline ~ ANY)*) }

/// A multi-line comment.
block_comment = _{ "/*" ~ (block_comment | !"*/" ~ ANY)* ~ "*/" }

/// A grammar comment.
COMMENT = _{ block_comment | line_comment }

// ref: https://doc.rust-lang.org/reference/comments.html
/// A space character.
space = _{ " " | "\t" }

/// A top-level comment.
grammar_doc = ${ "//!" ~ space? ~ inner_doc }

/// A rule comment.
line_doc = ${ "///" ~ space? ~ inner_doc }

/// A comment content.
inner_doc = @{ (!newline ~ ANY)* }
